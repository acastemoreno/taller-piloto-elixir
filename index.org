#+TITLE: Taller Piloto de Elixir
#+SUBTITLE: Elixir Language
#+DATE: 2017/04/29（Sabado）19:51
#+AUTHOR: Albert Castellano Moreno
#+EMAIL: acastemoreno@gmail.com
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+CREATOR: Emacs 25.2.1
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: es
#+SELECT_TAGS: export

#+GITHUB: http://github.com/acastemoreno

#+FAVICON: images/elixir.png
#+ICON: images/elixir.png

** Amiguito. Quién eres?
  :PROPERTIES:
  :ARTICLE:  smaller
  :END:
Formación:
- Estudiante Pre-pregrado en Ingeniería Mecánica - Universidad Nacional de Ingeniería - Finalizando el 2017-1
- Programación?: Autodidacta (php, python, ruby, prolog, clojure, haskell, elixir ♥)
Experiencia Laboral:
- Trabajos Freelancer con Symfony (framework php)
- Participación en organización de eventos nacionales e internacionales de ASME.
- Webmaster y Program Chair en Junta Estudiantil LainAmerica ASME
- Webmaster y Vice-chair en SEASME-UNI
- Trabajos freelancer Elixir y Phoenix para Termochilca y Enel
- Coach en Makerlab ♥
- Practicas pre-profesional en Control System Integration

* Información sobre el taller
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** El camino a Elixir
- Inicio taller: Viernes 26 de Mayo
- Duración del taller: 3 meses.
- Proyecto aplicando programación convencional (como si nuestras maquinas solo tuviese un solo procesador) : Calculo de velocidad de escape, distancia orbital, Llamaradas solares.
- Proyecto aplicando programación concurrente (programación distribuida, forma moderna de hacer aplicaciones web):
  - Primera Parte: un game engine
  - Segunda Parte: real time application usando el game engine de la primera parte

** Aclaraciónes
- El taller no se trata de verme programar, xD
- Toda pregunta es bien recibida.
- No tengan miedo a experimentar.
- No tengan miedo a equivocarse.
- Cero algoritmos.
- Programar de manera limpia y expresiva.

** Clase Modelo
- Programación.
- Programación funcional.
- Elixir: Historia, Sintaxis y Pattern Matching.

* Programación
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** [[https://www.youtube.com/watch?v=8pTEmbeENF4][The future of Programing]]
  :PROPERTIES:
  :FILL:     images/4_ideas.png
  :TITLE:    white
  :SLIDE:    white
  :END:

** Resumen
- "Tecnologia cambia rapidamente"
- "La mente de las persona cambia lentamente"
- "4 grandes ideas"
- "Ideas que requiere personas que desaprendan lo que saben y piensen de manera diferente"
- =Programadores que tienen una definición precisa de programación caen en DOGMAS. -> Resistencia a la Innovación.=

** Secuencial -> Concurrente
- Serie de instrucciones (Computadora, haz esto, luego esto, luego esto, .........)
- Esto debido al Hardware (Maquina de Von Neumann)
#+BEGIN_CENTER
#+ATTR_HTML: :width 450px
[[file:images/neumann.png]]
#+END_CENTER

** 
  :PROPERTIES:
  :FILL:     images/parallel.png
  :TITLE:    white
  :SLIDE:    white
  :END:

** 
  :PROPERTIES:
  :FILL:     images/threads.png
  :TITLE:    white
  :SLIDE:    white
  :END:

** 
#+BEGIN_CENTER
#+ATTR_HTML: :width 900px
[[file:images/multithreaded_programming.jpg]]
#+END_CENTER


** [[https://youtu.be/xoNRtWl4fZU][Processing 2.7 million images with Elixir (vs Ruby) by David Padilla ]]
#+BEGIN_CENTER
#+ATTR_HTML: :width 600px
[[file:images/ruby_process.png]]
#+END_CENTER

** 
  :PROPERTIES:
  :FILL:     images/ruby_results.png
  :TITLE:    white
  :SLIDE:    white
  :END:

** Entonces como programamos en un array de procesadores?
#+BEGIN_CENTER
#+ATTR_HTML: :width 700px
[[file:images/modelo-actor.png]]
#+END_CENTER

* Programación Funcional
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Jerga en Programación Funcional
- Inmutabilidad
- Pureza
- Currying

** Inmutabilidad
  :PROPERTIES:
  :ARTICLE:  smaller
  :END:
Mutabilidad en Js
#+BEGIN_SRC js
var ShoppingCart = function(){
  items = [];

  this.agregarItem = function(item){
    //encontrar el item, si es que no fue agregado anteriormente.
  };

  this.total = function(){
    var sum = 0;
    //loop a travez de los items y sumandolos
  }

  this.contar = function(){
    return items.length;
  }
};

var cart = new ShoppingCart();
cart.agregarItem({sku: "MAV", precio: 10000000000});
#+END_SRC

** 
Agregar Items a la instancia creada:
#+BEGIN_SRC js
cart.agregarItem({sku: "ROVER", precio: 3333223322});
cart.agregarItem({sku: "HAB", precio: 4433222234});
#+END_SRC
Desde un enfoque funcional (inmutabilidad):
#+BEGIN_SRC js
cartNoItems = ShoppingCart.new()
cartStateOneItem = ShoppingCart.agregarItem(cartNoItems, 
                                  {sku: "MAV", price: 10000000000})
cartStateTwoItems = ShoppingCart.agregarItem(cartStateOneItem, 
                                  {sku: "ROVER", price: 3333223322})
cartStateThreeItems = ShoppingCart.agregarItem(cartStateTwoItems, 
                                  {sku: "HAB", price: 4433222234})
#+END_SRC
** Pureza: 
- "Data in, data out. Nada más es requerido"
- Referido como caracteristica de funciones.
- En una funcion pura, la salida o resultado de las operaciones siempre dependen de los parametros que reciba. Todo comportamiento es predecible.
- Una funcion impura puede comunicarse con archivos y base de datos. El resultado de la funcion no solo depende de los argumentos.
** Elixir: Rompe reglas.
- Elixir es un lenguaje funcional impuro porque puede comunicarse con base de datos, leer y modificar archivos.
- Elixir puede reasignar variables.
#+BEGIN_SRC elixir
animal = "Perro" # La variable animal se enlaza con el texto "Perro"
animal = "Gato"  # La variable animal se reenlaza con el texto "Gato"
#+END_SRC
#+BEGIN_SRC elixir
cart = ShoppingCart.new()
cart = ShoppingCart.agregarItem(cart, {sku: "MAV", price: 10000000000})
cart = ShoppingCart.agregarItem(cart, {sku: "ROVER", price: 3333223322})
cart = ShoppingCart.agregarItem(cart, {sku: "HAB", price: 4433222234})
#+END_SRC
** 
  :PROPERTIES:
  :ARTICLE: smaller
  :END:
En elixir no existen estructuras mutables, por lo que reasignar (que si es permitido en elixir) es una solucion requerida. Si nos fijamos, la funcion agregarItem ahora es una funcion que transforma el primer parametro que se le pase.
#+BEGIN_SRC elixir
cart = ShoppingCart.new()
cart = ShoppingCart.agregarItem(cart, {sku: "MAV", price: 10000000000})
cart = ShoppingCart.agregarItem(cart, {sku: "ROVER", price: 3333223322})
cart = ShoppingCart.agregarItem(cart, {sku: "HAB",  price: 4433222234})
#+END_SRC
Interesante. Si ampliamos el concepto de funcion como transformación de información (cadena productiva y transformadora) podemos usar lo siguiente:
#+BEGIN_SRC elixir
cart = ShoppingCart.new()
  |> ShoppingCart.agregarItem({sku: "MAV", price: 10000000000})
  |> ShoppingCart.agregarItem({sku: "ROVER", price: 3333223322})
  |> ShoppingCart.agregarItem({sku: "HAB", price: 4433222234})
#+END_SRC
Se ejecuta la funcion "new" para luego su resultado ser transformado sucesivamente por la funcion agregarItem. Codigo elegante ♥

Ejemplo:
#+BEGIN_SRC elixir
1..100 |> Enum.map(&(&1*&1)) |> Enum.filter(&(&1<50))
#+END_SRC
** Currying (Pre-Debugging)
  :PROPERTIES:
  :ARTICLE: smaller
  :END:
#+BEGIN_QUOTE
"Chaining small functions in sequence" (rather than having a large function do a lot of stuff)
    
   -- Haskell Curry
#+END_QUOTE
#+BEGIN_CENTER
#+ATTR_HTML: :Width 250px
[[file:images/HaskellBCurry.jpg]]
#+END_CENTER
** 
#+BEGIN_SRC elixir
def convertir_a_segundos_luz(millas) do
  metros= millas * 1609.34
  metros * 3.335638620368e-9
end
#+END_SRC

Currying:
#+BEGIN_SRC elixir 
def a_metros(millas) when is_integer(millas) do
  millas * 1609.34
end

def a_segundos_luz(millas) do
  (millas |> a_metros) * 3.335638620368e-9
end
#+END_SRC
* Elixir
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:
** [[https://youtu.be/xrIjfIjssLE][Erlang The Movie - 1986]]
:PROPERTIES:
:ARTICLE:  smaller
:END:
#+BEGIN_CENTER
#+ATTR_HTML: :width 300px
[[file:images/erlang_the_movie.jpg]]
#+END_CENTER
** Jose Valim: Creador de Elixir (2011)
:PROPERTIES:
:ARTICLE:  smaller
:END:
#+BEGIN_CENTER
#+ATTR_HTML: :width 350px
[[file:images/jose_valim.jpg]]
#+END_CENTER
-Parte del Core Team de Ruby On Rails
#+BEGIN_QUOTE
一I loved everything I saw in Erlang, but I hated the things I didn't see.

      -- José Valim
#+END_QUOTE
** Proceso de Creación
#+BEGIN_CENTER
#+ATTR_HTML: :width 700px
[[file:images/pineapple_pen.gif]]
#+END_CENTER
** Erlang + Ruby + Clojure
#+BEGIN_CENTER
#+ATTR_HTML: :width 400px
[[file:images/logos.jpg]]
#+END_CENTER
** 
  :PROPERTIES:
  :ARTICLE: large
  :END:
#+BEGIN_QUOTE
Elixir is what would happen if Erlang, Clojure, and Ruby somehow had a baby and it wasn’t an accident.
  --Devin Torres
#+END_QUOTE


#+BEGIN_QUOTE
Elixir offers developers the functional power and concurrent resilience of Erlang, with friendlier syntax, libraries and metaprogramming.

  --Simon St. Laurent
#+END_QUOTE

* Familiarizandonos con Elixir
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Simple y limpio
  :PROPERTIES:
  :ARTICLE:  larger
  :END:
#+BEGIN_CENTER
#+BEGIN_EXPORT html
<div>
 <p class="gray"># Esto es un comentario</p>
 <p>titulo = <span class="blue">"un texto"</span><p>
 <p>precio = <span class="green">24.50</span><p>
 <p>cantidad = <span class="green">2</p>
 <p class="red">:atomo<p>
<div>
#+END_EXPORT
#+END_CENTER

** Construcciones Comunes
#+BEGIN_CENTER
#+BEGIN_EXPORT html
<div>
 <p>tuple = {<span class="red">:metros</span>, <span class="green">50</span>, <span class="blue">"holi"</span>}</p>
 <p>list = [<span class="blue">"ultimo"</span>, <span class="blue">"segundo"</span>, <span class="blue">"primero"</span>]</p>
 <p>keyword_list = [<span class="red">font:</span> <span class="blue">"Arial"</span>, <span class="red">style:</span> <span class="blue">"bold"</span>, <span class="red">style:</span> <span class="blue">"italic"</span>]</p>
 <p>map = %{<span class="red">nombre:</span> <span class="blue">"Albert"</span>, <span class="red">edad:</span> <span class="green">25</span>}</p>
 <p>struct = %<span class="purple">Persona</span>{<span class="red">nombre:</span> <span class="blue">"Albert"</span>, <span class="red">apellidos:</span> <span class="blue">"Castellano Moreno"</span>, <span class="red">edad:</span> <span class="green">25</span>}</p>
<div>
#+END_EXPORT
#+END_CENTER

* Operadores
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Qué son los Operadores?
#+BEGIN_QUOTE
一Operators can be seen as a special form of function with different calling notation and a limited number of parameters.

      -- Wikipedia
#+END_QUOTE

* func(left, right)
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

* left <operador> right
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Operadores Matematicos
#+BEGIN_SRC elixir
iex> 1 + 1
2
iex> 5 - 2
3
iex> 15 / 3
5.0
iex> 3 * 5
15
#+END_SRC
* Comparadores
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:
** Igualdad
#+BEGIN_SRC elixir
iex> "Albert" == "Albert"
true
iex> 1 == 2
false
iex> 1 == 1.0
true
iex> 1 === 1.0
false
#+END_SRC
** Inegualdad: =!== y =!===
#+BEGIN_SRC elixir
iex> 1 != 2
true
iex> 1 != 1.0
false
iex> 1 !== 1.0
true
#+END_SRC

** Mayor/Menor que
=>=, =>==, =<=, =<==

Ejemplos:
#+BEGIN_SRC elixir
iex> 2 > 1
true
iex> 2 >= 2
true
iex> 1 < 2
true
iex> 1 <= 2
true
#+END_SRC

* Operadores logicos
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Operaciones Booleanas
Esperan solo =true=, =false=. Estos operadores son: =and=, =or= y =not=

Ejemplos:
#+BEGIN_SRC elixir
iex> true and true
true
iex> true or false
true
iex> not true
false
#+END_SRC

* Operador Match "="
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

* patron = data
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Operador Match
#+BEGIN_SRC elixir
iex> nombre = "Albert"
"Albert"
iex> edad  = 25
25
#+END_SRC
** Operador Match
Las variables pueden reenlazarse.

Ejemplo:
#+BEGIN_SRC elixir
iex> nombre = "Albert"
"Albert"
iex> nombre = "Amiguito"
"Amiguito"
#+END_SRC

** Operador Match
El operador match es en realidad una afirmación que nosotros hacemos y que elixir tratara de hacer verdad enlazando valores a las variables que participen.

Ejemplo:
#+BEGIN_SRC elixir
iex> {nombre, edad} = {"Albert", 25}
{"Albert", 25}
iex> nombre
"Albert"
iex> edad
25
#+END_SRC

** Operador Match
Variables solo pueden enlazar una vez por match.

Ejemplo:
#+BEGIN_SRC elixir
#Contrajemplo
iex> {edad, edad} = {24, 25}
(MatchError) no match of right hand side value: {24, 25}
#+END_SRC

** Operador Match
Usamos =_= para ignorar elementos en un match.

Ejemplo:
#+BEGIN_SRC elixir
iex> {nombre, _} = {"Albert", 25}
{"Albert", 25}
iex> nombre
"Albert"
#Tambien puedo usar la siguiente forma solo por un tema de doocumentación
iex> {nombre, _edad} = {"Albert", 25}
{"Albert", 25}
iex> edad
warning: ...........
#+END_SRC

** Operador Match
Parte del contenido del patron puede contener información que debera ser matcheada en el lado de la data.

Ejemplo:
#+BEGIN_SRC elixir
iex> {"Albert", edad} = {"Albert", 25}
{"Albert", 25}
iex> edad
25

iex> {"Amiguito", edad} = {"Albert", 25}
(MatchError) no match of right hand side value:
#+END_SRC

** Operador Match
Usamos =^= cuando queremos usar el valor de las variables en el lado del patron.

Ejemplo:
#+BEGIN_SRC elixir
iex> nombre = "Albert"
"Albert"
iex> {^nombre, edad} = {"Albert", 25}
{"Albert", 25}
iex> edad
25
#+END_SRC

** Operador Match
Todos los tipos de datos vistos hasta hora pueden ser matcheados.

Ejemplo:
#+BEGIN_SRC elixir
#Mapas
iex> %{nombre: nombre, edad: edad} = %{nombre: "Albert", edad: 25}
#Estructuras
iex> %Persona{} = %Persona{nombre: "Albert", edad: 25}
{"Albert", 25}
#Binarios
iex> "Hola " <> palabra = "Hola Mundo"
"Hola Mundo"
iex> palabra
mundo
#+END_SRC

* Funciones anonimas
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Creando funciones anonimas
Las funciones anonimas tienen la siguiente forma: =fn(<parametro1>, <parametro2>, ....) -> <ejecucion y retorno> end=

Crearemos funciones en IEx y las guardaremos en una variable para posteriormente utilizarlas:

#+BEGIN_SRC elixir
iex> velocidad = fn (distancia) -> :math.sqrt(2 * 9.81 * distancia) end
#Function<6.52032458/1 in :erl_eval.expr/5>
## El retorno nos sirve para corroborrar que hemos creado una funcion y 
## no resulto en error.
iex> sum = fn (a, b) -> a + b end
#Function<12.17052888 in :erl_eval.expr/5>
iex> sum.(1, 2)
3
#+END_SRC

** Evaluamos la función
:PROPERTIES:
:ARTICLE:  smaller
:END:
#+BEGIN_SRC elixir
iex> velocidad = fn (distancia) -> :math.sqrt(2 * 9.81 * distancia) end
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> velocidad.(3)
7.672027111526653
iex> sum = fn (a, b) -> a + b end
#Function<12.17052888 in :erl_eval.expr/5>
iex> sum.(1, 2)
3
#+END_SRC
Al ejecutar =velocidad.(3)=, un patron se matchea con la data suministrada. 

En el ejemplo, el patron =distancia= se matchea con =3= (=distancia = 3=). Esto resulta en la asignacion de =3= a la variable =distancia=. 

Para luego ser utilizada en la evaluacion =:math.sqrt(2 * 9.81 * distancia)=. 

=:math.sqrt= toma la raiz cuadrada de la expresion.

Nota: el =:math= es un modulo de Erlang. Usar atomos en minusculas nos sirve para llamar modulos de Erlang (sean modulos propio del lenguaje o mediante librerias).

** Funciones anonimas creadas en multiples Lineas
Ahora podemos separar en piezas nuestras funciones dentro de multiples lineas, esto hace que sea más legible. IEx mantiene la linea abierta hasta que tipees =end=. El ejemplo anterior de esta manera:
#+BEGIN_SRC elixir
##En este caso obviamos englobar en parentesis
##los parametros porque solo existe uno solo.
iex> velocidad = fn 
...> distancia -> :math.sqrt(2 * 9.81 * distancia)
...> end
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> velocidad.(10)
14.007141035914502
#+END_SRC
** Funciones Anonimas y Pattern Matching
Como anterioremente explique, cada vez que evaluamos una funcion anonima, un patron se matchea con la data suministrada, de lo cual deriva en asignaciones, para que luego sean utilizadas. Esto significa que se puede hacer matcheos de mayor complejidad
Ejemplos:
#+BEGIN_SRC elixir
##En este caso se esta pasando un solo parametro que es una tupla y se esta devolviendo otra tupla con el orden invertido.
iex> intercambio = fn 
...> {primero, segundo} -> {segundo, primero}
...> end
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> intercambio.({6, 8})
{8, 6}
#+END_SRC
** Una funcion anonima, multiples cuerpos
Para el siguiente ejemplo, en mi carpeta creo un archivo =holiwoli.txt= que no es necesario que tenga contenido.

#+BEGIN_CENTER
#+ATTR_HTML: :width 650px
[[file:images/holiwoli.png]]
#+END_CENTER
** 
Ejecuto =iex= en la carpeta donde cree =holiwoli.txt= y ejecuto una que me intereza. Analizamos el uso de una funcion llamada =open=, dentro de la libreria =File=, que por defecto Elixir ya incorpora.
#+BEGIN_CENTER
#+ATTR_HTML: :width 650px
[[file:images/file_open.png]]
#+END_CENTER
Al ejecutar la funcion, esta retorna una tupla, tal que su primer elemento es un atomo que representa el exito o fracaso de la operación, y el segundo es segun el primer termino, un identificador unico de proceso ó un mensaje de error.
** 
Ahora creamos una funcion anonima que procese ese resultado y dependiendo del caso hace una accion u otra.
#+BEGIN_SRC elixir
iex> verificar_archivo = fn 
...> {:ok, archivo} -> "Leyendo archivo: #{IO.read(archivo, :line)}"
...> {_, error}  -> "Error: #{:file.format_error(error)}"
...> end
#Function<6.52032458/1 in :erl_eval.expr/5>
#+END_SRC
** 
:PROPERTIES:
:ARTICLE:  smaller
:END:
#+BEGIN_CENTER
#+ATTR_HTML: :width 850px
[[file:images/verificar_archivo.png]]
#+END_CENTER
Lo que hace la función es verificar el primer primer patron que en este caso es ={:ok, archivo}=. Si consigue hacer el match ={:ok, archivo} = File.open(".......")= imprime el texto =Leyendo archivo: ........=, y si no matchea intentara hacer un nuevo match con ={_, error}= de la siguiente forma ={_, error} = File.open(".......")=, si logra hacer este ultimo match se imprimira el texto =Error: ..........=

Significa que importa el orden indicado de los patrones.

* Shortcut &
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** 
:PROPERTIES:
:ARTICLE:  smaller
:END:
Hemos observador hasta el momento que para crear una funcion anonima es necesario definir 2 partes importantes:
- El patron
- El contenido que ejecuta
Ahora, existe algo más practico que toma en concideracion el orden de los parametros que se estan tomando. Eso más practico es el uso de =&= para definir funciones anonimas. 

Aqui un ejemplo en la forma como se utilizan.
#+BEGIN_SRC elixir
iex> doble = &(&1 * 2)
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> doble.(7)
14
#+END_SRC
=&(...)= se refiere a la creacion de una funcion anonima. =&1= representa el primer parametro obtenido al evaluar la funcion. Entonces =&(&1 * 2)= es una funcion anonima de aridad 1 que toma su primer parametro (primer y unico parametro) y devuelve el doble.
** 
=&(....)= tiene las siguientes variaciones:
- =&{....}=: Funcion anonima que crea una tupla como resultado
- =&[....]=: Funcion anonima que crea una lista como resultado
Ejemplos:
#+BEGIN_SRC elixir
iex> cociente_residuo = &{ div(&1,&2), rem(&1,&2) }
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> cociente_residuo.(13, 5)
{2, 3}
iex> lista = &[&1, &1 * 2, &1 * 3]
#Function<6.52032458/1 in :erl_eval.expr/5>
iex> lista.(5)
[5, 10, 15]
#+END_SRC
** Usos de &
Sabemos que hace =&(....)=, pero para que sirve?

Sirve crear funciones anonimas que sirvan como parametros a otras funciones..

Ejemplos:
#+BEGIN_SRC elixir
iex> Enum.map [1,2,3,4], &(&1 + 1)
[2, 3, 4, 5]
iex> Enum.map [1,2,3,4], &(&1 * &1)
[1, 4, 9, 16]
iex> Enum.map [1,2,3,4], &(&1 < 3)
[true, true, false, false]
#+END_SRC

* Thank You ˊ・ω・ˋ
:PROPERTIES:
:SLIDE: thank-you-slide segue
:ASIDE: right
:ARTICLE: flexbox vleft auto-fadein
:END:
